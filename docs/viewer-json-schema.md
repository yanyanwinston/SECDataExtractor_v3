# Viewer JSON Schema Documentation

## Overview

This document describes the structure of the JSON data embedded in the iXBRL viewer HTML generated by Arelle's iXBRLViewerPlugin. This schema is based on analysis of actual Apple 10-K filing viewer output (Arelle 2.37+ format).

## Top-Level Structure

The viewer JSON follows this hierarchy:

```json
{
  "sourceReports": [{
    "targetReports": [{
      "concepts": {},     // Concept definitions with labels
      "facts": {},        // Compressed fact storage
      "target": {},       // Target document metadata
      "roleDefs": {},     // Role ID to statement name mapping
      "rels": {},         // Relationship networks (presentation, calculation, etc.)
      "localDocs": {}     // Documentation references
    }]
  }]
}
```

## Key Components

### 1. Role Definitions (`roleDefs`)

Maps short role IDs to human-readable statement descriptions.

**Structure:**
```json
{
  "ns9": {
    "en": "0000005 - Statement - CONSOLIDATED BALANCE SHEETS"
  },
  "ns11": {
    "en": "0000008 - Statement - CONSOLIDATED STATEMENTS OF CASH FLOWS"
  },
  "ns13": {
    "en": "0000003 - Statement - CONSOLIDATED STATEMENTS OF OPERATIONS"
  }
}
```

**Key Mappings (Apple 10-K):**
- `ns9` = Balance Sheet
- `ns11` = Cash Flow Statement
- `ns13` = Income Statement
- `ns12` = Comprehensive Income
- `ns14` = Shareholders' Equity

### 2. Presentation Relationships (`rels.pres`)

Contains the hierarchical structure of financial statements as parent-child relationships.

**Structure:**
```json
{
  "ns9": {  // Balance Sheet role
    "us-gaap:StatementOfFinancialPositionAbstract": [
      {
        "t": "us-gaap:AssetsAbstract"
      },
      {
        "t": "us-gaap:LiabilitiesAndStockholdersEquityAbstract"
      }
    ],
    "us-gaap:AssetsAbstract": [
      {
        "t": "us-gaap:AssetsCurrentAbstract"
      },
      {
        "t": "us-gaap:AssetsNoncurrentAbstract"
      },
      {
        "t": "us-gaap:Assets"
      }
    ],
    "us-gaap:AssetsCurrentAbstract": [
      {
        "t": "us-gaap:CashAndCashEquivalentsAtCarryingValue"
      },
      {
        "t": "us-gaap:MarketableSecuritiesCurrent"
      }
    ]
  }
}
```

**Key Properties:**
- Each parent concept maps to an array of child relationships
- Child objects contain `t` (target concept) property
- Order in array determines presentation order
- Some relationships may include `l` (preferred label role) property

### 3. Facts (`facts`)

Compressed storage of all fact values with context information.

**Structure:**
```json
{
  "f-123": {
    "a": {
      "c": "us-gaap:CashAndCashEquivalentsAtCarryingValue",
      "e": "e:0000320193",
      "m": false,
      "p": "2023-09-30"
    },
    "v": "29965000000"
  },
  "f-456": {
    "a": {
      "c": "us-gaap:Assets",
      "e": "e:0000320193",
      "m": "usd",
      "p": "2023-09-30"
    },
    "v": "352755000000"
  }
}
```

**Fact Attributes (`a` object):**
- `c` = Concept name (XBRL qualified name)
- `e` = Entity identifier
- `m` = Unit/measure (e.g., "usd", "shares", false for dimensionless)
- `p` = Period identifier (instant date or start/end range)

**Fact Properties:**
- `v` = Value (string representation)
- Additional contexts may exist as `b`, `c`, etc. for same fact with different periods

### 4. Concepts (`concepts`)

Definitions for all XBRL concepts with their labels.

**Structure:**
```json
{
  "us-gaap:CashAndCashEquivalentsAtCarryingValue": {
    "labels": {
      "ns0": {
        "en-us": "Cash and cash equivalents"
      },
      "std": {
        "en-us": "Cash and Cash Equivalents"
      }
    },
    "b": "debit",
    "dt": "xbrli:monetaryItemType"
  }
}
```

**Label Types:**
- `std` = Standard label
- `ns0` = Terse label (shorter version)
- `ns1` = Total label (for totals/subtotals)
- `ns2` = Negated terse label
- `ns4` = Negated standard label
- `ns7` = Negated total label

**Additional Properties:**
- `b` = Balance type ("debit" or "credit")
- `dt` = Data type
- `d` = "t" if dimensional concept
- `e` = true if extensible enumeration

## Parsing Strategy

### 1. Extract Financial Statements

```python
def get_financial_statements(viewer_data):
    """Extract main financial statement roles."""
    target = viewer_data['sourceReports'][0]['targetReports'][0]
    role_defs = target['roleDefs']

    statements = {}
    for role_id, role_info in role_defs.items():
        name = role_info.get('en', '')
        if 'Statement -' in name:
            statements[role_id] = name

    return statements
```

### 2. Build Presentation Tree

```python
def build_presentation_tree(role_id, viewer_data):
    """Build hierarchical presentation tree for a statement."""
    target = viewer_data['sourceReports'][0]['targetReports'][0]
    pres_rels = target['rels']['pres'].get(role_id, {})
    concepts = target['concepts']

    def build_node(concept_name, depth=0):
        concept_info = concepts.get(concept_name, {})
        children = []

        if concept_name in pres_rels:
            for child_rel in pres_rels[concept_name]:
                child_concept = child_rel['t']
                child_node = build_node(child_concept, depth + 1)
                children.append(child_node)

        return PresentationNode(
            concept=concept_name,
            label=get_best_label(concept_info),
            depth=depth,
            abstract=not has_facts_for_concept(concept_name),
            children=children
        )

    # Find root nodes (concepts that aren't children of others)
    all_children = set()
    for parent, children in pres_rels.items():
        for child in children:
            all_children.add(child['t'])

    root_concepts = [c for c in pres_rels.keys() if c not in all_children]

    return [build_node(concept) for concept in root_concepts]
```

### 3. Match Facts to Concepts

```python
def find_fact_for_concept(concept, period, viewer_data):
    """Find fact value for specific concept and period."""
    target = viewer_data['sourceReports'][0]['targetReports'][0]
    facts = target['facts']

    for fact_id, fact_data in facts.items():
        fact_attrs = fact_data['a']

        if (fact_attrs.get('c') == concept and
            fact_attrs.get('p') == period):
            return {
                'value': fact_data['v'],
                'unit': fact_attrs.get('m'),
                'entity': fact_attrs.get('e')
            }

    return None
```

## Key Differences from Specification

The actual viewer JSON structure differs from the original refactor spec in several ways:

1. **Simpler Relationship Format**: Presentation relationships are stored as flat parent-child arrays, not nested trees
2. **No Order Property**: Presentation order is implicit in array sequence, not explicit `order` values
3. **Compressed Keys**: Facts use single-letter keys (`c`, `p`, `e`, `v`) for compactness
4. **Label Structure**: Labels are nested objects with language codes, not simple strings
5. **Multiple Contexts**: Facts may have multiple period contexts as `a`, `b`, `c` properties

## Statement Type Detection

```python
def classify_statement_type(role_name):
    """Classify statement type from role definition."""
    name_lower = role_name.lower()

    if 'balance sheet' in name_lower:
        return StatementType.BALANCE_SHEET
    elif 'operations' in name_lower or 'income' in name_lower:
        return StatementType.INCOME_STATEMENT
    elif 'cash flow' in name_lower:
        return StatementType.CASH_FLOWS
    elif 'comprehensive income' in name_lower:
        return StatementType.COMPREHENSIVE_INCOME
    elif 'equity' in name_lower or 'shareholders' in name_lower:
        return StatementType.EQUITY
    else:
        return StatementType.OTHER
```

## Usage in Refactor

This schema documentation serves as the foundation for:

1. **Phase 2**: Creating presentation-based data models
2. **Phase 3**: Implementing the presentation parser
3. **Phase 4**: Integration with existing pipeline
4. **Testing**: Validating parser behavior against real data

The key insight is that Arelle has already done the hard work of parsing the presentation linkbase - we just need to extract and use this structure correctly instead of trying to reconstruct it from raw facts.